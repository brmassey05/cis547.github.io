---
layout: lab
_id: "5"
title: "Statistical Debugging"
synopsis: |
    Building a statistical debugger for remote program monitoring and debugging.
---

### Objective  

In this lab, you will implement cooperative bug isolation (CBI) to
statistically localize error locations in a program.
You need to implement an LLVM pass that instruments each branch and function
call to report the values of their conditions and return values.
You will then generate a number of sample inputs using a fuzzer.
With these inputs, you will obtain the runtime data from the instrumentation
and measure different types of scores that help isolate bugs
and guide de-bugging effort.

### Setup

The skeleton code for Lab 5 is located under `/cis547vm/lab5/`.
We will frequently refer to the top level directory for Lab 5 as `lab5`
when describing file locations for the lab.
Open the `lab5` directory in VSCode following the Instructions
from [Course VM document][Course VM Document].

The lab in split into three parts:
   1. In part 1, you will implement two instrumentations, one to
   instrument each conditional branch instruction reporting the condition.
   And  another that instruments all function calls, to report their
   return values.
   2. In part 2, you will run a fuzzer to generate a set of inputs
   that will be used to collect data for performing statistical analysis.
   3. In part 3, you will run the target program with the inputs generated
   by the fuzzer to collect cbi logs and analyze the data
   to report various metrics.

To build the instrumentation, you can use the following commands:

```sh
lab5$ mkdir build && cd build
lab5/build$ cmake ..
lab5/build$ make
```

You should now see `CBIInstrumentPass.so`, `libruntime.so`, and
`InstrumentPass.so` in the build directory.

The `cbi` tool performs statistical debugging for a program using a feedback
profile (which you will generate) for successful and erroneous program runs.

To help generate program runs that pass or fail, you will use a `fuzzer`:

```sh
lab5$ cd test
lab5/test$ make
lab5/test$ rm -rf fuzz_output_sanity && mkdir fuzz_output_sanity
lab5/test$ timeout 1 fuzzer ./sanity fuzz_input fuzz_output_sanity 10
```

Or alternativele you can have the `Makefile` to do this for you using:

```sh
lab5/test$ make fuzz-sanity
```

To setup the `cbi` tool you can run:

```sh
lab5$ make install
```

This will install the `cbi` tool, just like what you had in `lab4`
for the `delta-debugger` tool.

You can then run `cbi` to generate a report of analyzing the runs of a program using:

```sh
lab5/test$ cbi ./sanity ./fuzz_output_sanity
```

Before completing the cbi program you should see the following report generated:

```
== S(P) ==

== F(P) ==

== Failure(P) ==

== Context(P) ==

== Increase(P) ==

```

### Lab Instructions

In short, the lab consists of the following tasks:
   1. Implement the `instrumentCBIBranche` function to insert a
   `__cbi_branch__` call for a predicate (conditional).
   2. Modify `runOnFunction` to instrument all branching instructions with
   the predicate recording logic.
   3. Implement the `instrumentReturn` function to insert a
   `__cbi_return__` call for a return value.
   4. Modify `runOnFunction` to instrument all integer return instructions with the return recording logic.
   5. Using the feedback profile you construct in 1-4, modify `generateReport` to implement statistical debugging.
   You should compute `F(P), S(P), Failure(P), Context(P)`, and `Increase(P)` which should be stored in the corresponding data structures in `include/Utils.h`.

##### Part 1: Instrumentation

In this part, you will edit the `lab5/src/CBIInstrument.cpp` file to
implement the cooperative bug isolation which will instrument branches
and return instructions with code to extract and monitor predicates.

`lab5/lib/runtime.c` contains functions that you will be instrumenting:

```c
void __cbi_branch__(int line, int col, int cond);

void __cbi_return__(int line, int col, int rv);
```

These functions appends corresponding predicate information as
json the following objects respectively:

```json
{"kind": "branch", "line": line, "col": col, "value": true/false}
{"kind": "return", "line": line, "col": col, "value": rv}
```

to the running process's cbi log file (`target.cbi.jsonl`).

Like you did in Lab 2, your LLVM pass should instrument the code with these functions.
Your pass should instrument each conditional branch with code that records whether the branch conditional is `true` or `false` on execution.
Likewise, instrument each call instruction that returns an
integer to record its runtime the return value.
The log file generated by these instrumentations will create a
*feedback profile* for you to perform statistical debugging
and generate a *feedback report*.

###### Revisiting Instrumentation.

By now you should feel comfortable working with the LLVM compiler infrastructure, but for a refresher, consult Lab 2 and see the paragraphs titled ["Inserting Instruction into LLVM Code"][lab2 instructions] and ["Loading C functions into LLVM"][lab2 instructions].

###### CBI File Infrastructure.

The `cbi` executable will execute the input program on each of the trace `input` files from a `fuzzer` output directory.
This includes both successful program runs (`fuzz_output/sucess`) and erroneous program runs (`fuzz_output/failure`).
Each run will generate an analogous feedback profile for each input file.
The resulting directory tree will look like this:
```
   -  fuzz_output/
      -  success/
         -  input1
         -  input1.cbi
         -  input2
         -  input2.cbi
         -  ...
      -  failure/
         -  input1
         -  input1.cbi
         - ...
```
You will use these `.cbi` files to generate the feedback report.

###### Generating the feedback report.

During the lesson, you saw how we use several metrics to help determine which predicates correlate with bugs.
One such metric, `Failure(P)`, calculates how often predicate P is true in a failing run.
Another metric, `Context(P)`, calculates the background chance of failure when predicate P is observed.
Finally, `Increase(P)` calculates the likelihood that P influences the success or failure of the program.

We have defined maps `F`, `S`, `Failure`, `Context`, and `Increase` in `lab5/include/Utils.h` that you should populate in `generateReport` located in `lab5/src/CBI.cpp`.
Notice each is a mapping from `std::tuple<int, int, State>` to `double`.
Here, the tuple represents a predicate, which consists of a line, column, and a State data type that encodes the possible predicates a branch or return has.

Note that your instrumentation will record where a branch or return occurs and its result, but you need to encode that into a predicate.
For example, if we encounter `if (p == 10) { ... }` in the code, we need to store two predicates, (p == 10), and (p != 10), which you would represent as `State::BranchTrue` and `State::BranchFalse`.  

The skeleton code will go through and print out your maps via `printReport`.  


### Example Input and Output

Your statistical debugger should run on any C code that compiles to LLVM IR.
As we demonstrated in the Setup section, we will compile code to LLVM and instrument the code with the fuzzer and cbi passes.

```sh
lab5$ cd test
lab5/test$ clang -emit-llvm -S -fno-discard-value-names -c fuzz1.c -g
lab5/test$ opt -load ../build/InstrumentPass.so -Instrument -S fuzz1.ll -o fuzz1.instruented.ll
lab5/test$ opt -load ../build/CBIInstrumentPass.so -CBIInstrument -S fuzz1.instrumented.ll -o fuzz1.cbi.instrumented.ll
lab5/test$ clang -o fuzz1 -L../build -lruntime fuzz1.cbi.instrumented.ll
```
After, we will run the fuzzer to generate a set of passing and failing inputs for use with the cbi tool.

```sh
lab5/test$ rm -rf fuzz_output && mkdir fuzz_output
lab5/test$ timeout 1 ../build/fuzzer ./fuzz1 fuzz_input fuzz_output 10
lab5/test$ ../build/cbi ./fuzz1 fuzz_output
```

You should expect to generate output similar to the following:

```sh
== S(P) ==
Line 10, Col 7, BranchTrue: 0
Line 10, Col 7, BranchFalse: 4
Line 14, Col 7, BranchTrue: 2
Line 14, Col 7, BranchFalse: 2
== F(P) ==
Line 10, Col 7, BranchTrue: 1
Line 10, Col 7, BranchFalse: 0
Line 14, Col 7, BranchTrue: 0
Line 14, Col 7, BranchFalse: 0
== Failure(P) ==
Line 10, Col 7, BranchTrue: 1
Line 10, Col 7, BranchFalse: 0
Line 14, Col 7, BranchTrue: 0
Line 14, Col 7, BranchFalse: 0
== Context(P) ==
Line 10, Col 7, BranchTrue: 0.2
Line 10, Col 7, BranchFalse: 0.2
Line 14, Col 7, BranchTrue: 0
Line 14, Col 7, BranchFalse: 0
== Increase(P) ==
Line 10, Col 7, BranchTrue: 0.8 
Line 10, Col 7, BranchFalse: -0.2 
Line 14, Col 7, BranchTrue: 0 
Line 14, Col 7, BranchFalse: 0
```


### Submission

Once you are done with the lab, you can create a `submission.zip` file by using the following command:
```sh
lab5$ make submit
...
submission.zip created successfully.
```

Then upload the submission file to Gradescope.


[lab2 instructions]: https://cis.upenn.edu/~cis547/lab2.doc
[Course VM Document]: https://cis.upenn.edu/~cis547/vm.doc



